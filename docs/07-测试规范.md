# 测试规范

## 1. 测试概述

### 1.1 测试目标
- 确保代码质量和功能正确性
- 提高代码可维护性
- 降低bug率
- 测试覆盖率≥80%

### 1.2 测试类型
- **单元测试**: 测试单个函数/方法
- **集成测试**: 测试模块间协作
- **功能测试**: 测试完整功能流程
- **性能测试**: 测试性能指标
- **压力测试**: 测试系统极限

### 1.3 测试原则
- **自动化**: 所有测试自动化执行
- **独立性**: 测试之间相互独立
- **可重复**: 测试结果可重复
- **快速**: 单元测试要快速执行
- **完整**: 覆盖所有代码路径

## 2. 单元测试

### 2.1 测试文件组织
- 测试文件与源文件同目录
- 测试文件以 `_test.go` 结尾
- 测试函数以 `Test` 开头

```
internal/
├── asr/
│   ├── manager.go
│   ├── manager_test.go
│   ├── provider.go
│   └── provider_test.go
```

### 2.2 测试函数规范
```go
func TestFunctionName(t *testing.T) {
    // 准备测试数据
    // 执行测试
    // 验证结果
}
```

### 2.3 表驱动测试
使用表驱动测试提高测试覆盖率：

```go
func TestProcessAudio(t *testing.T) {
    tests := []struct {
        name    string
        input   []byte
        want    string
        wantErr bool
        errMsg  string
    }{
        {
            name:    "valid audio",
            input:   []byte{0x00, 0x01, 0x02},
            want:    "result",
            wantErr: false,
        },
        {
            name:    "empty audio",
            input:   []byte{},
            want:    "",
            wantErr: true,
            errMsg:  "audio data is empty",
        },
        {
            name:    "invalid format",
            input:   []byte{0xFF, 0xFF},
            want:    "",
            wantErr: true,
            errMsg:  "invalid audio format",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ProcessAudio(tt.input)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("ProcessAudio() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            
            if tt.wantErr && err != nil {
                if !strings.Contains(err.Error(), tt.errMsg) {
                    t.Errorf("ProcessAudio() error = %v, want error containing %v", err, tt.errMsg)
                }
                return
            }
            
            if got != tt.want {
                t.Errorf("ProcessAudio() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

### 2.4 测试覆盖率
- 使用 `go test -cover` 查看覆盖率
- 使用 `go test -coverprofile=coverage.out` 生成覆盖率文件
- 使用 `go tool cover -html=coverage.out` 查看HTML报告
- 目标覆盖率: ≥80%

### 2.5 Mock和Stub
使用接口和依赖注入实现Mock：

```go
// 定义接口
type ASRProvider interface {
    Transcribe(audio []byte) (string, error)
}

// Mock实现
type MockASRProvider struct {
    TranscribeFunc func([]byte) (string, error)
}

func (m *MockASRProvider) Transcribe(audio []byte) (string, error) {
    if m.TranscribeFunc != nil {
        return m.TranscribeFunc(audio)
    }
    return "mock result", nil
}

// 测试中使用Mock
func TestManager(t *testing.T) {
    mockProvider := &MockASRProvider{
        TranscribeFunc: func(audio []byte) (string, error) {
            if len(audio) == 0 {
                return "", fmt.Errorf("empty audio")
            }
            return "test result", nil
        },
    }
    
    manager := NewManager(mockProvider)
    result, err := manager.Process([]byte{0x01, 0x02})
    // 验证结果
}
```

### 2.6 测试工具
- **testify**: 断言库
  ```go
  import "github.com/stretchr/testify/assert"
  
  assert.Equal(t, expected, actual)
  assert.NoError(t, err)
  assert.Contains(t, err.Error(), "expected message")
  ```

- **httptest**: HTTP测试
  ```go
  import "net/http/httptest"
  
  req := httptest.NewRequest("GET", "/api/v1/health", nil)
  w := httptest.NewRecorder()
  handler(w, req)
  assert.Equal(t, http.StatusOK, w.Code)
  ```

## 3. 集成测试

### 3.1 集成测试组织
```
test/
├── integration/
│   ├── asr_test.go
│   ├── tts_test.go
│   └── websocket_test.go
```

### 3.2 测试环境
- 使用Docker Compose搭建测试环境
- 包含所有依赖服务
- 测试数据隔离

```go
func TestASRIntegration(t *testing.T) {
    // 启动测试服务
    server := startTestServer(t)
    defer server.Close()
    
    // 测试识别功能
    client := NewClient(server.URL)
    result, err := client.Recognize(testAudioData)
    assert.NoError(t, err)
    assert.NotEmpty(t, result)
}
```

### 3.3 数据库测试
- 使用测试数据库
- 每个测试前清理数据
- 使用事务回滚

```go
func TestWithDatabase(t *testing.T) {
    db := setupTestDB(t)
    defer db.Close()
    
    // 测试数据库操作
    session := &Session{ID: "test-id"}
    err := db.Create(session)
    assert.NoError(t, err)
    
    // 清理
    db.Delete(session)
}
```

### 3.4 外部服务Mock
- 使用httptest模拟外部服务
- 使用testcontainers测试容器服务

```go
func TestWithExternalService(t *testing.T) {
    // 启动Mock服务
    mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"result": "success"}`))
    }))
    defer mockServer.Close()
    
    // 测试使用Mock服务
    client := NewClient(mockServer.URL)
    result, err := client.CallAPI()
    assert.NoError(t, err)
}
```

## 4. 功能测试

### 4.1 端到端测试
测试完整的用户流程：

```go
func TestSTTEndToEnd(t *testing.T) {
    // 1. 启动服务
    server := startServer(t)
    defer server.Close()
    
    // 2. 建立WebSocket连接
    conn := connectWebSocket(t, server.URL)
    defer conn.Close()
    
    // 3. 发送音频数据
    audioData := loadTestAudio(t)
    err := conn.WriteMessage(websocket.BinaryMessage, audioData)
    assert.NoError(t, err)
    
    // 4. 接收识别结果
    _, message, err := conn.ReadMessage()
    assert.NoError(t, err)
    
    var result RecognitionResult
    err = json.Unmarshal(message, &result)
    assert.NoError(t, err)
    assert.NotEmpty(t, result.Text)
}
```

### 4.2 API测试
使用httptest测试REST API：

```go
func TestSTTAPI(t *testing.T) {
    router := setupRouter(t)
    
    // 测试文件上传
    body := &bytes.Buffer{}
    writer := multipart.NewWriter(body)
    part, _ := writer.CreateFormFile("audio", "test.wav")
    part.Write(testAudioData)
    writer.Close()
    
    req := httptest.NewRequest("POST", "/api/v1/stt/recognize", body)
    req.Header.Set("Content-Type", writer.FormDataContentType())
    w := httptest.NewRecorder()
    
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusOK, w.Code)
    var response RecognitionResponse
    json.Unmarshal(w.Body.Bytes(), &response)
    assert.NotEmpty(t, response.Text)
}
```

### 4.3 WebSocket测试
使用gorilla/websocket测试WebSocket：

```go
func TestWebSocket(t *testing.T) {
    server := httptest.NewServer(setupWebSocketHandler())
    defer server.Close()
    
    url := "ws" + strings.TrimPrefix(server.URL, "http") + "/ws"
    conn, _, err := websocket.DefaultDialer.Dial(url, nil)
    assert.NoError(t, err)
    defer conn.Close()
    
    // 发送消息
    err = conn.WriteMessage(websocket.TextMessage, []byte(`{"type": "test"}`))
    assert.NoError(t, err)
    
    // 接收消息
    _, message, err := conn.ReadMessage()
    assert.NoError(t, err)
    assert.NotEmpty(t, message)
}
```

## 5. 性能测试

### 5.1 基准测试
使用 `Benchmark` 函数：

```go
func BenchmarkProcessAudio(b *testing.B) {
    data := make([]byte, 1024)
    for i := 0; i < b.N; i++ {
        ProcessAudio(data)
    }
}

func BenchmarkConcurrentProcess(b *testing.B) {
    data := make([]byte, 1024)
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            ProcessAudio(data)
        }
    })
}
```

运行基准测试：
```bash
go test -bench=. -benchmem
```

### 5.2 性能指标
- **延迟**: P50, P95, P99延迟
- **吞吐量**: QPS (Queries Per Second)
- **资源使用**: CPU, 内存使用率
- **并发能力**: 最大并发数

### 5.3 性能测试工具
- **go test -bench**: Go内置基准测试
- **pprof**: 性能分析工具
- **JMeter**: 压力测试工具

```go
import _ "net/http/pprof"

func main() {
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    // ...
}
```

## 6. 压力测试

### 6.1 并发测试
测试系统并发处理能力：

```go
func TestConcurrentRequests(t *testing.T) {
    const numRequests = 100
    const concurrency = 10
    
    server := startServer(t)
    defer server.Close()
    
    var wg sync.WaitGroup
    sem := make(chan struct{}, concurrency)
    errors := make(chan error, numRequests)
    
    for i := 0; i < numRequests; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            sem <- struct{}{}
            defer func() { <-sem }()
            
            _, err := makeRequest(server.URL)
            if err != nil {
                errors <- err
            }
        }()
    }
    
    wg.Wait()
    close(errors)
    
    errorCount := 0
    for err := range errors {
        if err != nil {
            errorCount++
        }
    }
    
    assert.Less(t, errorCount, numRequests/10, "error rate should be less than 10%")
}
```

### 6.2 负载测试
使用工具进行负载测试：

```bash
# 使用ab (Apache Bench)
ab -n 1000 -c 10 http://localhost:8080/api/v1/health

# 使用wrk
wrk -t4 -c100 -d30s http://localhost:8080/api/v1/health
```

### 6.3 压力测试场景
- **正常负载**: 预期QPS的50%
- **峰值负载**: 预期QPS的100%
- **超载测试**: 预期QPS的150%
- **极限测试**: 系统最大承受能力

## 7. 测试数据管理

### 7.1 测试数据
- 使用固定的测试数据
- 测试数据与代码分离
- 使用fixtures管理测试数据

```
test/
├── fixtures/
│   ├── audio/
│   │   ├── test_zh.wav
│   │   ├── test_en.wav
│   │   └── test_empty.wav
│   └── text/
│       ├── test_zh.txt
│       └── test_en.txt
```

### 7.2 测试数据生成
```go
func generateTestAudio(duration time.Duration) []byte {
    sampleRate := 16000
    samples := int(duration.Seconds() * float64(sampleRate))
    data := make([]int16, samples)
    
    for i := range data {
        data[i] = int16(math.Sin(2 * math.Pi * 440 * float64(i) / float64(sampleRate)) * 32767)
    }
    
    buffer := new(bytes.Buffer)
    binary.Write(buffer, binary.LittleEndian, data)
    return buffer.Bytes()
}
```

## 8. 测试执行

### 8.1 本地测试
```bash
# 运行所有测试
go test ./...

# 运行特定包的测试
go test ./internal/asr

# 运行测试并查看覆盖率
go test -cover ./...

# 生成覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

### 8.2 CI/CD测试
```yaml
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-go@v2
        with:
          go-version: '1.21'
      - run: go test -v -coverprofile=coverage.out ./...
      - run: go tool cover -func=coverage.out
      - name: Upload coverage
        uses: codecov/codecov-action@v2
        with:
          file: ./coverage.out
```

### 8.3 测试报告
- 测试结果汇总
- 覆盖率报告
- 性能测试报告
- 失败测试详情

## 9. 测试最佳实践

### 9.1 测试编写
- **AAA模式**: Arrange, Act, Assert
- **测试名称**: 清晰描述测试内容
- **测试隔离**: 每个测试独立运行
- **快速执行**: 单元测试要快速

### 9.2 测试维护
- 及时更新测试用例
- 删除过时的测试
- 重构测试代码
- 保持测试代码质量

### 9.3 测试覆盖
- **语句覆盖**: 执行所有语句
- **分支覆盖**: 覆盖所有分支
- **函数覆盖**: 测试所有函数
- **行覆盖**: 覆盖所有代码行

目标: 总体覆盖率≥80%，关键模块覆盖率≥90%

## 10. GPU测试

### 10.1 GPU可用性测试
```go
func TestGPUAvailable(t *testing.T) {
    if !isGPUAvailable() {
        t.Skip("GPU not available, skipping test")
    }
    
    // 测试GPU功能
    provider, err := NewProvider(ProviderConfig{Provider: "cuda"})
    assert.NoError(t, err)
    assert.NotNil(t, provider)
}
```

### 10.2 GPU性能测试
```go
func BenchmarkGPUvsCPU(b *testing.B) {
    if !isGPUAvailable() {
        b.Skip("GPU not available, skipping benchmark")
    }
    
    // CPU基准测试
    b.Run("CPU", func(b *testing.B) {
        provider := NewCPUProvider()
        benchmarkProvider(b, provider)
    })
    
    // GPU基准测试
    b.Run("GPU", func(b *testing.B) {
        provider := NewGPUProvider()
        benchmarkProvider(b, provider)
    })
}
```

### 10.3 GPU回退测试
```go
func TestGPUFallback(t *testing.T) {
    // 模拟GPU不可用
    originalCheck := checkGPU
    defer func() { checkGPU = originalCheck }()
    
    checkGPU = func() bool { return false }
    
    // 应该自动回退到CPU
    provider, err := NewProvider(ProviderConfig{Provider: "auto"})
    assert.NoError(t, err)
    assert.Equal(t, "cpu", provider.GetProvider())
}
```

### 10.4 GPU资源管理测试
```go
func TestGPUResourceManagement(t *testing.T) {
    if !isGPUAvailable() {
        t.Skip("GPU not available")
    }
    
    manager := NewGPUResourceManager(1024) // 1GB限制
    
    // 测试显存分配
    err := manager.Allocate(512)
    assert.NoError(t, err)
    
    // 测试显存溢出
    err = manager.Allocate(1024)
    assert.Error(t, err)
    
    // 测试显存释放
    manager.Release(512)
    err = manager.Allocate(1024)
    assert.NoError(t, err)
}
```

## 11. 测试工具和框架

### 11.1 Go测试工具
- `go test`: 内置测试工具
- `go test -race`: 竞态检测
- `go test -cover`: 覆盖率分析
- `go test -bench`: 基准测试

### 11.2 第三方工具
- **testify**: 断言库
- **httptest**: HTTP测试
- **testcontainers**: 容器测试
- **gomock**: Mock生成工具
- **nvidia-smi**: GPU监控工具

### 11.3 持续集成
- **GitHub Actions**: CI/CD
- **GitLab CI**: CI/CD
- **Jenkins**: CI/CD
- **CircleCI**: CI/CD
- **GPU CI**: 支持GPU的CI环境

