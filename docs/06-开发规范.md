# 开发规范

## 1. Go语言开发最佳实践

### 1.1 代码风格

#### 1.1.1 命名规范
- **包名**: 小写，简短，有意义
  ```go
  // 好的命名
  package config
  package logger
  package asr
  
  // 不好的命名
  package Config
  package myPackage
  package pkg
  ```

- **变量名**: 驼峰命名，简短有意义
  ```go
  // 好的命名
  var userName string
  var maxRetries int
  var isConnected bool
  
  // 不好的命名
  var user_name string
  var max_retries int
  var flag bool
  ```

- **函数名**: 驼峰命名，动词开头
  ```go
  // 好的命名
  func GetUser() {}
  func CreateSession() {}
  func IsValid() bool {}
  
  // 不好的命名
  func getUser() {}
  func create_session() {}
  func valid() bool {}
  ```

- **接口名**: 驼峰命名，通常以-er结尾
  ```go
  // 好的命名
  type Reader interface {}
  type Writer interface {}
  type ASRProvider interface {}
  
  // 不好的命名
  type Read interface {}
  type Write interface {}
  ```

- **常量**: 全大写，下划线分隔
  ```go
  const (
      MaxRetries = 3
      DefaultTimeout = 30 * time.Second
      API_VERSION = "v1"
  )
  ```

#### 1.1.2 代码格式
- 使用 `gofmt` 格式化代码
- 使用 `goimports` 管理导入
- 遵循 Go 官方代码风格指南

#### 1.1.3 注释规范
- **包注释**: 每个包必须有包注释
  ```go
  // Package config provides configuration management functionality.
  package config
  ```

- **导出函数**: 所有导出函数必须有注释
  ```go
  // NewManager creates a new ASR manager instance.
  // It initializes the ASR provider and resource pool.
  func NewManager(config *Config) (*Manager, error) {
      // ...
  }
  ```

- **复杂逻辑**: 复杂逻辑必须有注释
  ```go
  // Convert PCM16 audio data to float32 samples.
  // The input is little-endian 16-bit PCM data.
  func convertPCM16ToFloat32(data []byte) []float32 {
      // ...
  }
  ```

### 1.2 错误处理

#### 1.2.1 错误返回
- 错误作为最后一个返回值
- 错误使用 `error` 类型
- 错误信息要清晰明确

```go
// 好的错误处理
func ProcessAudio(data []byte) (string, error) {
    if len(data) == 0 {
        return "", fmt.Errorf("audio data is empty")
    }
    // ...
    return result, nil
}

// 不好的错误处理
func ProcessAudio(data []byte) string {
    if len(data) == 0 {
        return "" // 没有错误信息
    }
    // ...
    return result
}
```

#### 1.2.2 错误包装
- 使用 `fmt.Errorf` 和 `%w` 包装错误
- 提供上下文信息

```go
func LoadModel(path string) error {
    data, err := os.ReadFile(path)
    if err != nil {
        return fmt.Errorf("failed to load model from %s: %w", path, err)
    }
    // ...
}
```

#### 1.2.3 错误检查
- 所有错误必须检查
- 不要忽略错误

```go
// 好的错误检查
result, err := ProcessAudio(data)
if err != nil {
    return fmt.Errorf("failed to process audio: %w", err)
}

// 不好的错误检查
result, _ := ProcessAudio(data) // 忽略了错误
```

### 1.3 并发安全

#### 1.3.1 互斥锁
- 使用 `sync.Mutex` 保护共享资源
- 锁的粒度要合适

```go
type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count++
}
```

#### 1.3.2 通道
- 使用通道进行goroutine间通信
- 明确通道的用途（发送/接收）

```go
// 好的通道使用
func worker(jobs <-chan Job, results chan<- Result) {
    for job := range jobs {
        result := process(job)
        results <- result
    }
}
```

#### 1.3.3 上下文
- 使用 `context.Context` 控制超时和取消
- 传递上下文到所有异步操作

```go
func ProcessWithTimeout(ctx context.Context, data []byte) (string, error) {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    resultCh := make(chan string, 1)
    errCh := make(chan error, 1)
    
    go func() {
        result, err := process(data)
        if err != nil {
            errCh <- err
            return
        }
        resultCh <- result
    }()
    
    select {
    case result := <-resultCh:
        return result, nil
    case err := <-errCh:
        return "", err
    case <-ctx.Done():
        return "", ctx.Err()
    }
}
```

### 1.4 资源管理

#### 1.4.1 资源释放
- 使用 `defer` 确保资源释放
- 及时释放不再使用的资源

```go
func ProcessFile(path string) error {
    file, err := os.Open(path)
    if err != nil {
        return err
    }
    defer file.Close() // 确保文件关闭
    
    // 处理文件
    return nil
}
```

#### 1.4.2 资源池
- 使用资源池复用资源
- 避免频繁创建/销毁资源

```go
type Pool struct {
    resources chan *Resource
    factory   func() *Resource
}

func (p *Pool) Get() *Resource {
    select {
    case r := <-p.resources:
        return r
    default:
        return p.factory()
    }
}

func (p *Pool) Put(r *Resource) {
    select {
    case p.resources <- r:
    default:
        // 池已满，丢弃资源
    }
}
```

### 1.5 测试

#### 1.5.1 单元测试
- 每个包都要有测试文件
- 测试文件以 `_test.go` 结尾
- 测试函数以 `Test` 开头

```go
func TestProcessAudio(t *testing.T) {
    tests := []struct {
        name    string
        input   []byte
        want    string
        wantErr bool
    }{
        {
            name:    "valid audio",
            input:   []byte{0x00, 0x01, 0x02},
            want:    "result",
            wantErr: false,
        },
        {
            name:    "empty audio",
            input:   []byte{},
            want:    "",
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ProcessAudio(tt.input)
            if (err != nil) != tt.wantErr {
                t.Errorf("ProcessAudio() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if got != tt.want {
                t.Errorf("ProcessAudio() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

#### 1.5.2 表驱动测试
- 使用表驱动测试提高测试覆盖率
- 测试用例要覆盖边界情况

#### 1.5.3 基准测试
- 使用 `Benchmark` 函数进行性能测试

```go
func BenchmarkProcessAudio(b *testing.B) {
    data := make([]byte, 1024)
    for i := 0; i < b.N; i++ {
        ProcessAudio(data)
    }
}
```

### 1.6 性能优化

#### 1.6.1 避免不必要的分配
- 使用对象池复用对象
- 预分配切片容量

```go
// 好的做法
result := make([]byte, 0, 1024) // 预分配容量

// 不好的做法
var result []byte // 每次append可能重新分配
```

#### 1.6.2 减少内存拷贝
- 使用切片而不是数组
- 避免不必要的字符串转换

```go
// 好的做法
func process(data []byte) {
    // 直接使用切片，不拷贝
}

// 不好的做法
func process(data []byte) {
    newData := make([]byte, len(data))
    copy(newData, data) // 不必要的拷贝
}
```

#### 1.6.3 并发优化
- 使用goroutine池限制并发数
- 使用缓冲通道提高吞吐量

```go
func ProcessBatch(jobs []Job) []Result {
    const numWorkers = 10
    jobCh := make(chan Job, len(jobs))
    resultCh := make(chan Result, len(jobs))
    
    // 启动worker
    for i := 0; i < numWorkers; i++ {
        go func() {
            for job := range jobCh {
                resultCh <- process(job)
            }
        }()
    }
    
    // 发送任务
    for _, job := range jobs {
        jobCh <- job
    }
    close(jobCh)
    
    // 收集结果
    results := make([]Result, 0, len(jobs))
    for i := 0; i < len(jobs); i++ {
        results = append(results, <-resultCh)
    }
    
    return results
}
```

## 2. 项目结构规范

### 2.1 目录结构
```
project/
├── cmd/              # 可执行程序入口
├── internal/          # 内部代码（不对外暴露）
├── pkg/              # 可复用的公共包
├── web/              # Web前端资源
├── configs/          # 配置文件
├── docs/             # 文档
├── scripts/           # 脚本
├── test/             # 测试文件
├── go.mod
└── README.md
```

### 2.2 包设计原则
- **单一职责**: 每个包只做一件事
- **低耦合**: 包之间依赖最小化
- **高内聚**: 包内功能相关性强

### 2.3 接口设计
- 接口要小，职责单一
- 接口命名清晰
- 优先使用接口而非具体类型

```go
// 好的接口设计
type ASRProvider interface {
    Transcribe(audio []byte) (string, error)
    GetSampleRate() int
}

// 不好的接口设计
type Provider interface {
    // 包含太多方法
    Transcribe(audio []byte) (string, error)
    Synthesize(text string) ([]byte, error)
    ProcessVideo(video []byte) (string, error)
}
```

## 3. 代码审查规范

### 3.1 审查清单
- [ ] 代码符合Go语言规范
- [ ] 错误处理完整
- [ ] 并发安全
- [ ] 资源正确释放
- [ ] 有适当的注释
- [ ] 有单元测试
- [ ] 测试覆盖率≥80%

### 3.2 审查流程
1. 提交Pull Request
2. 自动CI检查（格式、测试、覆盖率）
3. 代码审查
4. 修改后重新审查
5. 合并到主分支

## 4. 版本控制规范

### 4.1 分支策略
- **main**: 主分支，稳定版本
- **develop**: 开发分支
- **feature/xxx**: 功能分支
- **bugfix/xxx**: 修复分支
- **release/xxx**: 发布分支

### 4.2 提交信息规范
```
<type>(<scope>): <subject>

<body>

<footer>
```

**类型**:
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式
- `refactor`: 重构
- `test`: 测试
- `chore`: 构建/工具

**示例**:
```
feat(asr): add batch recognition support

Add support for batch audio file recognition.
This allows processing multiple files in a single request.

Closes #123
```

### 4.3 标签规范
- 版本号: `v1.0.0`
- 格式: `v<major>.<minor>.<patch>`

## 5. 依赖管理

### 5.1 依赖选择
- 优先使用官方库
- 选择活跃维护的库
- 避免过度依赖

### 5.2 版本管理
- 使用 `go.mod` 管理依赖
- 固定版本号，避免使用 `latest`
- 定期更新依赖

### 5.3 依赖审查
- 审查依赖的许可证
- 检查依赖的安全性
- 避免引入不必要的依赖

## 6. 文档规范

### 6.1 代码文档
- 所有导出函数、类型、常量都要有文档
- 使用 `godoc` 格式
- 提供使用示例

### 6.2 API文档
- 使用OpenAPI/Swagger规范
- 提供请求/响应示例
- 说明错误码

### 6.3 项目文档
- README.md: 项目介绍、快速开始
- CHANGELOG.md: 版本变更记录
- CONTRIBUTING.md: 贡献指南

## 7. 安全规范

### 7.1 输入验证
- 验证所有用户输入
- 防止注入攻击
- 限制输入大小

### 7.2 敏感信息
- 不在代码中硬编码密钥
- 使用环境变量或配置文件
- 日志中不输出敏感信息

### 7.3 资源限制
- 限制请求大小
- 限制并发数
- 限制资源使用

## 8. Cursor Rules 转换

以下规范可以转换为 `.cursorrules` 文件：

```markdown
# Go语言开发规范

## 代码风格
- 使用gofmt格式化代码
- 使用goimports管理导入
- 遵循Go官方代码风格指南

## 命名规范
- 包名: 小写，简短，有意义
- 变量名: 驼峰命名，简短有意义
- 函数名: 驼峰命名，动词开头
- 接口名: 驼峰命名，通常以-er结尾
- 常量: 全大写，下划线分隔

## 错误处理
- 错误作为最后一个返回值
- 使用fmt.Errorf和%w包装错误
- 所有错误必须检查

## 并发安全
- 使用sync.Mutex保护共享资源
- 使用通道进行goroutine间通信
- 使用context.Context控制超时和取消

## 资源管理
- 使用defer确保资源释放
- 使用资源池复用资源

## 测试
- 每个包都要有测试文件
- 使用表驱动测试
- 测试覆盖率≥80%

## 性能优化
- 避免不必要的分配
- 减少内存拷贝
- 使用goroutine池限制并发数
```

保存为 `.cursorrules` 文件，Cursor会自动应用这些规范。

